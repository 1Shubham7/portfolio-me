<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Kubernetes Statefulsets | Shubham Singh</title>
<meta name="keywords" content="Kubernetes, Statefulsets, K8s, DevOps">
<meta name="description" content="In simplest terms StatefulSets are Kubernetes component that is used specifically for stateful applications. These are workload API object used to manage stateful applications. They manage the deployment and scaling of a set of Pods (Creating more replicas or deleting them), and StatefulSets are also responsible for the ordering and uniqueness of these Pods. StatefulSet was released in the Kubernetes 1.9 release...">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/blog/statefulsets/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.2b833c6baa7a96407c2417c7a4049985b42c21cccc2472abf4603967eafd2273.css" integrity="sha256-K4M8a6p6lkB8JBfHpASZhbQsIczMJHKr9GA5Z&#43;r9InM=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.2eadbb982468c11a433a3e291f01326f2ba43f065e256bf792dbd79640a92316.js" integrity="sha256-Lq27mCRowRpDOj4pHwEybyukPwZeJWv3ktvXlkCpIxY="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="http://localhost:1313/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/favicon-32x32.png">
<link rel="apple-touch-icon" href="http://localhost:1313/apple-touch-icon.png">
<link rel="mask-icon" href="http://localhost:1313/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/blog/statefulsets/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Kubernetes Statefulsets" />
<meta property="og:description" content="In simplest terms StatefulSets are Kubernetes component that is used specifically for stateful applications. These are workload API object used to manage stateful applications. They manage the deployment and scaling of a set of Pods (Creating more replicas or deleting them), and StatefulSets are also responsible for the ordering and uniqueness of these Pods. StatefulSet was released in the Kubernetes 1.9 release..." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://localhost:1313/blog/statefulsets/" />
<meta property="og:image" content="http://localhost:1313/blog/jwt-logo.png" /><meta property="article:section" content="blog" />



<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="http://localhost:1313/blog/jwt-logo.png" />
<meta name="twitter:title" content="Kubernetes Statefulsets"/>
<meta name="twitter:description" content="In simplest terms StatefulSets are Kubernetes component that is used specifically for stateful applications. These are workload API object used to manage stateful applications. They manage the deployment and scaling of a set of Pods (Creating more replicas or deleting them), and StatefulSets are also responsible for the ordering and uniqueness of these Pods. StatefulSet was released in the Kubernetes 1.9 release..."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Blogs",
      "item": "http://localhost:1313/blog/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Kubernetes Statefulsets",
      "item": "http://localhost:1313/blog/statefulsets/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Kubernetes Statefulsets",
  "name": "Kubernetes Statefulsets",
  "description": "In simplest terms StatefulSets are Kubernetes component that is used specifically for stateful applications. These are workload API object used to manage stateful applications. They manage the deployment and scaling of a set of Pods (Creating more replicas or deleting them), and StatefulSets are also responsible for the ordering and uniqueness of these Pods. StatefulSet was released in the Kubernetes 1.9 release...",
  "keywords": [
    "Kubernetes", "Statefulsets", "K8s", "DevOps"
  ],
  "articleBody": "StatefulSets are API objects in Kubernetes that are used to manage stateful applications. There are two types of applications in Kubernetes, Stateful applications and stateless applications. There are two ways to deploy these applications:\nDeployment (for stateless applications) StatefulSets (for stateful applications) What are Stateful Applications? Those applications that maintain some form of persistent state or data are called stateful applications. The key characteristic that differentiates them from stateless applications is that these applications don’t rely on storing data locally and they don’t treat each request as independent. They manage data between interactions. Sometimes stateless applications connect to the stateful application to forward the requests to a database.\nWhat are Stateless Applications? Those applications that do not maintain any form of persistent state or data locally are called stateless applications. In stateless applications, each request or interaction is treated independently. These applications are designed to be highly scalable, easy to manage, and fault-tolerant because, unlike Stateful applications, they don’t have to track past interactions or requests.\nStateless applications are deployed using deployment component. Deployment is an abstraction of pods and allows you to replicate the application, meaning it allows you to run to 1, 5, 10 or n identical pods of the same stateless application.\nWhat are StatefulSets? In simplest terms StatefulSets are Kubernetes component that is used specifically for stateful applications. These are workload API object used to manage stateful applications. They manage the deployment and scaling of a set of Pods (Creating more replicas or deleting them), and StatefulSets are also responsible for the ordering and uniqueness of these Pods. StatefulSet was released in the Kubernetes 1.9 release.\nStatefulSets will represent the set of pods with different (unique), persistent identities, and elastic hostnames (stable). It makes you assure about the ordering of scaling and deployments. Before understanding StatefulSets, you must understand Kubernetes Deployment.\nHere is an example of a StatefulSet named web:\napiVersion: apps/v1 kind: StatefulSet metadata: name: web spec: serviceName: \"nginx\" replicas: 4 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: registry.k8s.io/nginx-slim:0.8 ports: - containerPort: 80 name: web volumeMounts: - name: www mountPath: /usr/share/nginx/html volumeClaimTemplates: - metadata: name: www spec: accessModes: [ \"ReadWriteOnce\" ] resources: requests: storage: 1Gi When to Use StatefulSets StatefulSets in Kubernetes are ideal for deploying stateful applications that require stable, unique network identifiers, persistent storage, and ordered, graceful deployment and scaling. They are suitable for applications like databases, key-value stores, and messaging queues that require consistent identity and storage.\nExample of Stateful and Stateless Applications Consider a node.js application connected to a MongoDB database. When a request comes to the node.js application it handles the request independently and does not depend on previous data to do that. It handles the request based on the payload in the request itself. This node.js application is an example of Stateless application. Now the request will either update some data in the database or query some data from the database. When node.js forwards that request to MongoDB, MongoDB updates the data based on the previous state of the data or query the data from its storage. For each request it needs to handle data and it depends upon the most up-to-date data or state to be available while node.js is just a pass-through for data updates or queries and it just processes code. Hence the node.js application should be a stateless application while the MongoDB application must be a stateful application.\nSometimes stateless applications connect to the stateful application to forward the requests to a database. This is a good example of a stateless application forwarding request to a stateful application.\nHow to Create a StatefulSet in Kubernetes Here is a step by step tutorial on how to use StatefulSets and some basic operations on StatefulSets.\nCreate a Nginx StatefulSet Application Step 1. Create a StatefulSet file. you can do that by entering the following command:\ntouch example-statefulset.yaml Step 2. Open this file in a code-editor and write the following code into it:\napiVersion: apps/v1 kind: StatefulSet metadata: name: gfg-example-statefulset annotations: description: \"This is an example statefulset\" spec: selector: matchLabels: app: nginx serviceName: \"gfg-example-service\" replicas: 3 # remember this, we will have 3 identical pods running template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx ports: - containerPort: 80 name: web volumeMounts: - name: www mountPath: /usr/share/nginx/html volumes: - name: www persistentVolumeClaim: claimName: myclaim Step 3. Now we have to create a service file and a PersistentVolumeClaim file.\ntouch example-service.yaml touch example-persistentVolumeChain.yaml Create a Service for the StatefulSet Application\nStep 4. Enter the following code into the service file:\napiVersion: v1 kind: Service metadata: name: gfg-example-service annotations: description: \"this is an example service\" labels: app: nginx spec: ports: - port: 80 name: web clusterIP: None selector: app: nginx Create a PersistentVolumeClaim for Application Step 5. Enter the following code into the PersistentVolumeClaim file: apiVersion: v1 kind: PersistentVolumeClaim metadata: name: myclaim spec: accessModes: - ReadWriteMany resources: requests: storage: 8Gi # This means we are requesting for 8 GB of storage Now lets apply these changes.\nStep 6. Enter the following command in your terminal to create the gfg-example-statefulset:\nkubectl create -f example-statefulset.yaml This will create our gfg-example-statefulset, you will get a similar result:\nnow if we search our StatefulSets in our terminal by the command\nkubectl get statefulsets we will find our gfg-example-statefulset in the list.\nStep 7. Enter the following command in your terminal to create the gfg-example-service.\nkubectl apply -f example-service.yaml this will create a service with the name “gfg-example-service”\nStep 8. Let’s check our pods and services, for getting the list of pods enter the following command in your terminal:\nkubectl get pods You will get the list of the three gfg- pods that we create though defining three replicas in the example-stateful-set.yaml file. You will get a similar output:\nfor checking the list of services, enter the following command in your terminal:\nkubectl get services This will give you similar output:\nKubectl get services\nSome Operations On StatefulSets Adding a StatefulSet: To add a StatefulSet to your Kubernetes cluster, use the command kubectl create -f [StatefulSet file name], replacing [StatefulSet file name] with the name of your StatefulSet manifest file.\nkubectl create -f StatefulSet_file_name Deleting a StatefulSet: To delete a StatefulSet in Kubernetes, you can use the kubectl delete statefulset [name] command, where [name] is the name of the StatefulSet you want to delete.\nkubectl delete statefulset [name]\nEditing a StatefulSet: The command kubectl edit statefulset [name] allows you to modify the configuration of a StatefulSet directly from the command line by opening an editor.\nkubectl edit statefulset [name]\nScaling of Replicas: The kubectl scale command scales the number of replicas in a StatefulSet named [StatefulSet name] to the specified [Number of replicas].\nkubectl scale statefulset [StatefulSet name] –replicas=[Number of replicas]\nStep 9. Now let’s scale up our pods and check if it works! for scaling up the pods to 6 pods, enter the following command:\nkubectl scale statefulset gfg-example-statefulset –replicas=6 This will create 3 more pods and number of pods are now 6, to get list of pods enter the following command:\nkubectl get pods You will get a similar output:\nKubectl get pods\nStep 10. Now let’s scale down pods to 3, for that enter the same command, just change the number of replicas back to 3:\nkubectl scale statefulset gfg-example-statefulset –replicas=3 now if we check the list of pods by\nkubectl get pods you will see only 3 pods running:\npods\nIn this way we can create StatefulSets, scale them up and then scale them down as well. Make sure to delete the StatefulSet and the service before closing the terminal.To know more commands of of kubectl refer to Kubectl Command Cheat Sheet.\nHow Stateful Applications Work? In stateful applications like MySQL, multiple pods cannot simultaneously read and write data to avoid data inconsistency. One pod is designated as the master pod, responsible for writing and changing data, while others are designated as slave pods, only allowed to read data. Each pod has its own replica of the data storage, ensuring data isolation and independence. Synchronization mechanisms are employed to ensure that all pods have the same data state, with slave pods updating their data storage when the master pod changes data. Continuous synchronization is necessary to maintain data consistency among all pods in the stateful applications.\nExample: Let’s say we have one master and two slave pods of MySQL. Now what happens when a new pod replica joins the existing setup? because now that new pod also needs to create its own storage and take care of synchronizing it what happens is that it first clones the data from the previous pod and then it starts continuous synchronization to listen for any updates by master pod. since each pod has its own data storage (persistent volume) that is backed up by its own physical storage which includes the synchronized data and the state of the pod. Each pod has its own state which has information about whether it’s a master pod or a slave pod and other individual characteristics. All of this gets stored in the pods own storage. Therefore when a pod dies and gets replaced the persistent pod. Identifiers make sure that the storage volume gets reattached to the replacement pod. In this way even if the cluster crashes, it is made sure that data is not lost.\nConclusion In this article we discussed about how to use Kubernetes StatefulSets. StatefulSets are Kubenetes components used to deploy stateful applications. Stateful applications are those applications that maintain some form of persistent state or data. A good example would be any application with a database. We discussed about how to deploy an stateful application using StatefulSets. After that we discussed how Stateful applications work? At the end we discussed the difference between StatefulSet and deployment which basically moves around the point that deployment are used to deploy stateless application and StatefulSets are used to deploy statefull applications. We will end this article by addressing some FAQs.\nKubernetes StatefulSets - FAQs How do I increase volume size in Kubernetes? To increase volume size in Kubernetes, you need to modify the PersistentVolumeClaim (PVC) specification by changing the storage size. Then, Kubernetes automatically provisions additional storage to meet the new size requirement, provided the underlying storage class supports dynamic provisioning.\nWhen to use hostPath in Kubernetes? The hostPath volume type in Kubernetes is suitable for scenarios where you need to access files or directories on the node’s filesystem directly within a pod. It’s commonly used for accessing node-specific resources or for sharing data between containers on the same node.\nWhat is the difference between PVC StatefulSet and deployment? PersistentVolumeClaims (PVCs) in StatefulSets are used to provide stable, persistent storage for individual pods, ensuring data persistence and identity across pod restarts. In contrast, deployments typically utilize ephemeral volumes, suitable for stateless applications where data persistence is not a requirement.\nCan We Deploy A Stateless Application Using StatefulSets? While technically possible, it’s not recommended to deploy stateless applications using StatefulSets. StatefulSets are specifically designed for stateful applications requiring stable, unique identifiers and persistent storage. Deploying stateless applications with StatefulSets can introduce unnecessary complexity and resource overhead.\nIs stateless better than stateful? It depends on the specific requirements of the application. Stateless applications are simpler to manage and scale horizontally, while stateful applications maintain data integrity and are better suited for certain workloads like databases or messaging systems.\n",
  "wordCount" : "1902",
  "inLanguage": "en",
  "image":"http://localhost:1313/blog/jwt-logo.png","datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "http://localhost:1313/blog/statefulsets/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Shubham Singh",
    "logo": {
      "@type": "ImageObject",
      "url": "http://localhost:1313/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header sticky-header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Shubham Singh (Alt + H)">Shubham Singh</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/experience" title="Experience">
                    <span>Experience</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/blog" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/projects" title="Projects">
                    <span>Projects</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/blog/">Blogs</a></div>
    <h1 class="post-title">
      Kubernetes Statefulsets
    </h1>
    <div class="post-description">
      In simplest terms StatefulSets are Kubernetes component that is used specifically for stateful applications. These are workload API object used to manage stateful applications. They manage the deployment and scaling of a set of Pods (Creating more replicas or deleting them), and StatefulSets are also responsible for the ordering and uniqueness of these Pods. StatefulSet was released in the Kubernetes 1.9 release...
    </div>
    <div class="post-meta">


October 2024

</div>
  </header> 
<figure class="entry-cover"><img loading="lazy" src="http://localhost:1313/blog/jwt-logo.png" alt="">
        
</figure><div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">‎ Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#what-are-stateful-applications" aria-label="What are Stateful Applications?">What are Stateful Applications?</a></li>
                <li>
                    <a href="#what-are-stateless-applications" aria-label="What are Stateless Applications?">What are Stateless Applications?</a></li>
                <li>
                    <a href="#what-are-statefulsets" aria-label="What are StatefulSets?">What are StatefulSets?</a></li>
                <li>
                    <a href="#when-to-use-statefulsets" aria-label="When to Use StatefulSets">When to Use StatefulSets</a><ul>
                        
                <li>
                    <a href="#example-of-stateful-and-stateless-applications" aria-label="Example of Stateful and Stateless Applications">Example of Stateful and Stateless Applications</a></li></ul>
                </li>
                <li>
                    <a href="#some-operations-on-statefulsets" aria-label="Some Operations On StatefulSets">Some Operations On StatefulSets</a></li>
                <li>
                    <a href="#how-stateful-applications-work" aria-label="How Stateful Applications Work?">How Stateful Applications Work?</a></li>
                <li>
                    <a href="#conclusion" aria-label="Conclusion">Conclusion</a></li>
                <li>
                    <a href="#kubernetes-statefulsets---faqs" aria-label="Kubernetes StatefulSets - FAQs">Kubernetes StatefulSets - FAQs</a><ul>
                        <ul>
                        
                <li>
                    <a href="#how-do-i-increase-volume-size-in-kubernetes" aria-label="How do I increase volume size in Kubernetes?">How do I increase volume size in Kubernetes?</a></li>
                <li>
                    <a href="#when-to-use-hostpath-in-kubernetes" aria-label="When to use hostPath in Kubernetes?">When to use hostPath in Kubernetes?</a></li>
                <li>
                    <a href="#what-is-the-difference-between-pvc-statefulset-and-deployment" aria-label="What is the difference between PVC StatefulSet and deployment?">What is the difference between PVC StatefulSet and deployment?</a></li>
                <li>
                    <a href="#can-we-deploy-a-stateless-application-using-statefulsets" aria-label="Can We Deploy A Stateless Application Using StatefulSets?">Can We Deploy A Stateless Application Using StatefulSets?</a></li>
                <li>
                    <a href="#is-stateless-better-than-stateful" aria-label="Is stateless better than stateful?">Is stateless better than stateful?</a>
                </li>
            </ul>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>StatefulSets are API objects in Kubernetes that are used to manage stateful applications. There are two types of applications in Kubernetes, Stateful applications and stateless applications. There are two ways to deploy these applications:</p>
<ul>
<li>Deployment (for stateless applications)</li>
<li>StatefulSets (for stateful applications)</li>
</ul>
<h2 id="what-are-stateful-applications">What are Stateful Applications?<a hidden class="anchor" aria-hidden="true" href="#what-are-stateful-applications">#</a></h2>
<p>Those applications that maintain some form of persistent state or data are called stateful applications. The key characteristic that differentiates them from stateless applications is that these applications don&rsquo;t rely on storing data locally and they don&rsquo;t treat each request as independent. They manage data between interactions. Sometimes stateless applications connect to the stateful application to forward the requests to a database.</p>
<h2 id="what-are-stateless-applications">What are Stateless Applications?<a hidden class="anchor" aria-hidden="true" href="#what-are-stateless-applications">#</a></h2>
<p>Those applications that do not maintain any form of persistent state or data locally are called stateless applications. In stateless applications, each request or interaction is treated independently. These applications are designed to be highly scalable, easy to manage, and fault-tolerant because, unlike Stateful applications, they don&rsquo;t have to track past interactions or requests.</p>
<p>Stateless applications are deployed using deployment component. Deployment is an abstraction of pods and allows you to replicate the application, meaning it allows you to run to 1, 5, 10 or n identical pods of the same stateless application.</p>
<h2 id="what-are-statefulsets">What are StatefulSets?<a hidden class="anchor" aria-hidden="true" href="#what-are-statefulsets">#</a></h2>
<p>In simplest terms StatefulSets are Kubernetes component that is used specifically for stateful applications. These are workload API object used to manage stateful applications. They manage the deployment and scaling of a set of Pods (Creating more replicas or deleting them), and StatefulSets are also responsible for the ordering and uniqueness of these Pods. StatefulSet was released in the Kubernetes 1.9 release.</p>
<p>StatefulSets will represent the set of pods with different (unique), persistent identities, and elastic hostnames (stable). It makes you assure about the ordering of scaling and deployments. Before understanding StatefulSets, you must understand Kubernetes Deployment.</p>
<p>Here is an example of a StatefulSet named web:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">apps/v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">StatefulSet</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">web</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">serviceName</span>: <span style="color:#e6db74">&#34;nginx&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">replicas</span>: <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">selector</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">matchLabels</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">app</span>: <span style="color:#ae81ff">nginx</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">template</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">labels</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">app</span>: <span style="color:#ae81ff">nginx</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">containers</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">nginx</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">image</span>: <span style="color:#ae81ff">registry.k8s.io/nginx-slim:0.8</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">ports</span>:
</span></span><span style="display:flex;"><span>        - <span style="color:#f92672">containerPort</span>: <span style="color:#ae81ff">80</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">name</span>: <span style="color:#ae81ff">web</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">volumeMounts</span>:
</span></span><span style="display:flex;"><span>        - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">www</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">mountPath</span>: <span style="color:#ae81ff">/usr/share/nginx/html</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">volumeClaimTemplates</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">name</span>: <span style="color:#ae81ff">www</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">accessModes</span>: [ <span style="color:#e6db74">&#34;ReadWriteOnce&#34;</span> ]
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">resources</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">requests</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">storage</span>: <span style="color:#ae81ff">1Gi</span>
</span></span></code></pre></div><h2 id="when-to-use-statefulsets">When to Use StatefulSets<a hidden class="anchor" aria-hidden="true" href="#when-to-use-statefulsets">#</a></h2>
<p>StatefulSets in Kubernetes are ideal for deploying stateful applications that require stable, unique network identifiers, persistent storage, and ordered, graceful deployment and scaling. They are suitable for applications like databases, key-value stores, and messaging queues that require consistent identity and storage.</p>
<h3 id="example-of-stateful-and-stateless-applications">Example of Stateful and Stateless Applications<a hidden class="anchor" aria-hidden="true" href="#example-of-stateful-and-stateless-applications">#</a></h3>
<p>Consider a node.js application connected to a MongoDB database. When a  request comes to the node.js application it handles the request independently and does not depend on previous data to do that. It handles the request based on the payload in the request itself. This node.js application is an example of Stateless application. Now the request will either update some data in the database or query some data from the database. When node.js forwards that request to MongoDB, MongoDB updates the data based on the previous state of the data or query the data from its storage. For each request it needs to handle data and it  depends upon the most up-to-date data or state to be available while node.js is just a pass-through for data updates or queries and it just processes code. Hence the node.js application should be a stateless application while the MongoDB application must be a stateful application.</p>
<p>Sometimes stateless applications connect to the stateful application to forward the requests to a database. This is a good example of a stateless application forwarding request to a stateful application.</p>
<p>How to Create a StatefulSet in Kubernetes
Here is a step by step tutorial on how to use StatefulSets and some basic operations on StatefulSets.</p>
<p>Create a Nginx StatefulSet Application
<strong>Step 1.</strong> Create a StatefulSet file. you can do that by entering the following command:</p>
<p>touch example-statefulset.yaml
<strong>Step 2.</strong> Open this file in a code-editor and write the following code into it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">apps/v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">StatefulSet</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">gfg-example-statefulset</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">annotations</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">description</span>: <span style="color:#e6db74">&#34;This is an example statefulset&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">selector</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">matchLabels</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">app</span>: <span style="color:#ae81ff">nginx</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">serviceName</span>: <span style="color:#e6db74">&#34;gfg-example-service&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">replicas</span>: <span style="color:#ae81ff">3</span> <span style="color:#75715e"># remember this, we will have 3 identical pods running</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">template</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">labels</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">app</span>: <span style="color:#ae81ff">nginx</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">containers</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">nginx</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">image</span>: <span style="color:#ae81ff">nginx</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">ports</span>:
</span></span><span style="display:flex;"><span>        - <span style="color:#f92672">containerPort</span>: <span style="color:#ae81ff">80</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">name</span>: <span style="color:#ae81ff">web</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">volumeMounts</span>:
</span></span><span style="display:flex;"><span>        - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">www</span>
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">mountPath</span>: <span style="color:#ae81ff">/usr/share/nginx/html</span>
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">volumes</span>:
</span></span><span style="display:flex;"><span>      - <span style="color:#f92672">name</span>: <span style="color:#ae81ff">www</span>
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">persistentVolumeClaim</span>:
</span></span><span style="display:flex;"><span>          <span style="color:#f92672">claimName</span>: <span style="color:#ae81ff">myclaim</span>
</span></span></code></pre></div><p><strong>Step 3.</strong> Now we have to create a service file and a PersistentVolumeClaim file.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>touch example-service.yaml
</span></span><span style="display:flex;"><span>touch example-persistentVolumeChain.yaml
</span></span></code></pre></div><p>Create a Service for the StatefulSet Application</p>
<p><strong>Step 4.</strong> Enter the following code into the service file:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">Service</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">gfg-example-service</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">annotations</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">description</span>: <span style="color:#e6db74">&#34;this is an example service&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">labels</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">app</span>: <span style="color:#ae81ff">nginx</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">ports</span>:
</span></span><span style="display:flex;"><span>  - <span style="color:#f92672">port</span>: <span style="color:#ae81ff">80</span>
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">name</span>: <span style="color:#ae81ff">web</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">clusterIP</span>: <span style="color:#ae81ff">None</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">selector</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">app</span>: <span style="color:#ae81ff">nginx</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">Create a PersistentVolumeClaim for Application</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">Step 5. Enter the following code into the PersistentVolumeClaim file</span>:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">apiVersion</span>: <span style="color:#ae81ff">v1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">kind</span>: <span style="color:#ae81ff">PersistentVolumeClaim</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">metadata</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">name</span>: <span style="color:#ae81ff">myclaim</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">spec</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">accessModes</span>:
</span></span><span style="display:flex;"><span>    - <span style="color:#ae81ff">ReadWriteMany</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">resources</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">requests</span>:
</span></span><span style="display:flex;"><span>      <span style="color:#f92672">storage</span>: <span style="color:#ae81ff">8Gi</span> <span style="color:#75715e"># This means we are requesting for 8 GB of storage</span>
</span></span></code></pre></div><p>Now lets apply these changes.</p>
<p><strong>Step 6.</strong> Enter the following command in your terminal to create the gfg-example-statefulset:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kubectl create -f example-statefulset.yaml
</span></span></code></pre></div><p>This will create our gfg-example-statefulset, you will get a similar result:</p>
<p><img loading="lazy" src="/blog/StatefulSets/one.png" alt="Output SS"  />
</p>
<p>now if we search our StatefulSets in our terminal by the command</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kubectl get statefulsets
</span></span></code></pre></div><p>we will find our gfg-example-statefulset in the list.</p>
<p><img loading="lazy" src="/blog/StatefulSets/three.png" alt="Output SS"  />
</p>
<p><strong>Step 7.</strong> Enter the following command in your terminal to create the gfg-example-service.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kubectl apply -f example-service.yaml
</span></span></code></pre></div><p>this will create a service with the name &ldquo;gfg-example-service&rdquo;</p>
<p><strong>Step 8.</strong> Let&rsquo;s check our pods and services, for getting the list of pods enter the following command in your terminal:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kubectl get pods
</span></span></code></pre></div><p>You will get the list of the three gfg- pods that we create though defining three replicas in the example-stateful-set.yaml file. You will get a similar output:</p>
<p><img loading="lazy" src="/blog/StatefulSets/two.png" alt="Output SS"  />
</p>
<p>for checking the list of services, enter the following command in your terminal:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kubectl get services
</span></span></code></pre></div><p>This will give you similar output:</p>
<p>Kubectl get services</p>
<h2 id="some-operations-on-statefulsets">Some Operations On StatefulSets<a hidden class="anchor" aria-hidden="true" href="#some-operations-on-statefulsets">#</a></h2>
<p>Adding a StatefulSet: To add a StatefulSet to your Kubernetes cluster, use the command kubectl create -f [StatefulSet file name], replacing [StatefulSet file name] with the name of your StatefulSet manifest file.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>kubectl create -f StatefulSet_file_name
</span></span></code></pre></div><p>Deleting a StatefulSet: To delete a StatefulSet in Kubernetes, you can use the kubectl delete statefulset [name] command, where [name] is the name of the StatefulSet you want to delete.</p>
<p>kubectl delete statefulset [name]</p>
<p>Editing a StatefulSet: The command kubectl edit statefulset [name] allows you to modify the configuration of a StatefulSet directly from the command line by opening an editor.</p>
<p>kubectl edit statefulset [name]</p>
<p>Scaling of Replicas: The kubectl scale command scales the number of replicas in a StatefulSet named [StatefulSet name] to the specified [Number of replicas].</p>
<p>kubectl scale statefulset [StatefulSet name] &ndash;replicas=[Number of replicas]</p>
<p><strong>Step 9.</strong> Now let&rsquo;s scale up our pods and check if it works! for scaling up the pods to 6 pods, enter the following command:</p>
<p>kubectl scale statefulset gfg-example-statefulset &ndash;replicas=6
This will create 3 more pods and number of pods are now 6, to get list of pods enter the following command:</p>
<p>kubectl get pods
You will get a similar output:</p>
<p>Kubectl get pods</p>
<p><strong>Step 10.</strong> Now let&rsquo;s scale down pods to 3, for that enter the same command, just change the number of replicas back to 3:</p>
<p>kubectl scale statefulset gfg-example-statefulset &ndash;replicas=3
now if we check the list of pods by</p>
<p>kubectl get pods
you will see only 3 pods running:</p>
<p>pods</p>
<p>In this way we can create StatefulSets, scale them up and then scale them down as well. Make sure to delete the StatefulSet and the service before closing the terminal.To know more commands of of kubectl refer to Kubectl Command Cheat Sheet.</p>
<h2 id="how-stateful-applications-work">How Stateful Applications Work?<a hidden class="anchor" aria-hidden="true" href="#how-stateful-applications-work">#</a></h2>
<p>In stateful applications like MySQL, multiple pods cannot simultaneously read and write data to avoid data inconsistency.
One pod is designated as the master pod, responsible for writing and changing data, while others are designated as slave pods, only allowed to read data.
Each pod has its own replica of the data storage, ensuring data isolation and independence.
Synchronization mechanisms are employed to ensure that all pods have the same data state, with slave pods updating their data storage when the master pod changes data.
Continuous synchronization is necessary to maintain data consistency among all pods in the stateful applications.</p>
<p>Example:
Let&rsquo;s say we have one master and two slave pods of MySQL. Now what happens when a new pod replica joins the existing setup? because now that new pod also needs to create its own storage and take care of synchronizing it what happens is that it first clones the data from the previous pod and then it starts continuous synchronization to listen for any updates by master pod. since each pod has its own data storage (persistent volume) that is backed up by its own physical storage which includes the synchronized data and the state of the pod. Each pod has its own state which has information about whether it&rsquo;s a master pod or a slave pod and other individual characteristics. All of this gets stored in the pods own storage. Therefore when a pod dies and gets replaced the persistent pod. Identifiers make sure that the storage volume gets reattached to the replacement pod. In this way even if the cluster crashes, it is made sure that data is not lost.</p>
<h2 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h2>
<p>In this article we discussed about how to use Kubernetes StatefulSets. StatefulSets are Kubenetes components used to deploy stateful applications. Stateful applications are those applications that maintain some form of persistent state or data. A good example would be any application with a database. We discussed about how to deploy an stateful application using StatefulSets. After that we discussed how Stateful applications work? At the end we discussed the difference between StatefulSet and deployment which basically moves around the point that deployment are used to deploy stateless application and StatefulSets are used to deploy statefull applications. We will end this article by addressing some FAQs.</p>
<h2 id="kubernetes-statefulsets---faqs">Kubernetes StatefulSets - FAQs<a hidden class="anchor" aria-hidden="true" href="#kubernetes-statefulsets---faqs">#</a></h2>
<h4 id="how-do-i-increase-volume-size-in-kubernetes">How do I increase volume size in Kubernetes?<a hidden class="anchor" aria-hidden="true" href="#how-do-i-increase-volume-size-in-kubernetes">#</a></h4>
<p>To increase volume size in Kubernetes, you need to modify the PersistentVolumeClaim (PVC) specification by changing the storage size. Then, Kubernetes automatically provisions additional storage to meet the new size requirement, provided the underlying storage class supports dynamic provisioning.</p>
<h4 id="when-to-use-hostpath-in-kubernetes">When to use hostPath in Kubernetes?<a hidden class="anchor" aria-hidden="true" href="#when-to-use-hostpath-in-kubernetes">#</a></h4>
<p>The hostPath volume type in Kubernetes is suitable for scenarios where you need to access files or directories on the node&rsquo;s filesystem directly within a pod. It&rsquo;s commonly used for accessing node-specific resources or for sharing data between containers on the same node.</p>
<h4 id="what-is-the-difference-between-pvc-statefulset-and-deployment">What is the difference between PVC StatefulSet and deployment?<a hidden class="anchor" aria-hidden="true" href="#what-is-the-difference-between-pvc-statefulset-and-deployment">#</a></h4>
<p>PersistentVolumeClaims (PVCs) in StatefulSets are used to provide stable, persistent storage for individual pods, ensuring data persistence and identity across pod restarts. In contrast, deployments typically utilize ephemeral volumes, suitable for stateless applications where data persistence is not a requirement.</p>
<h4 id="can-we-deploy-a-stateless-application-using-statefulsets">Can We Deploy A Stateless Application Using StatefulSets?<a hidden class="anchor" aria-hidden="true" href="#can-we-deploy-a-stateless-application-using-statefulsets">#</a></h4>
<p>While technically possible, it&rsquo;s not recommended to deploy stateless applications using StatefulSets. StatefulSets are specifically designed for stateful applications requiring stable, unique identifiers and persistent storage. Deploying stateless applications with StatefulSets can introduce unnecessary complexity and resource overhead.</p>
<h4 id="is-stateless-better-than-stateful">Is stateless better than stateful?<a hidden class="anchor" aria-hidden="true" href="#is-stateless-better-than-stateful">#</a></h4>
<p>It depends on the specific requirements of the application. Stateless applications are simpler to manage and scale horizontally, while stateful applications maintain data integrity and are better suited for certain workloads like databases or messaging systems.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/kubernetes/">Kubernetes</a></li>
      <li><a href="http://localhost:1313/tags/statefulsets/">Statefulsets</a></li>
      <li><a href="http://localhost:1313/tags/k8s/">K8s</a></li>
      <li><a href="http://localhost:1313/tags/devops/">DevOps</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="http://localhost:1313/">Shubham Singh</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
